---
title: hapter 12 存储类别 链接和内存管理
date: 2023/4/5 23:17:25  # 文章发表时间
tags:
- C_learning
categories: C
#thumbnail: https://xxxxxxxxxx.png # 略缩图
---
## 12.1 存储类别

每个数据都储存在内存中，每一个值都占用一定的物理内存，C语言把这种内存称为**对象**

对象可以存储一个或多个值，C语言不是面向对象编程的语言，是面向过程的编程语言

`int entity=3;`

该声明创建了一个标识符，标识符用来制定特定对象的内容

`int *pt=&entity`

制定对象的表达式被称为左值

*pt不是标识符，因为它不是一个名称，但他确实制定了一个对象

*pt即是表达式又是左值

如果是对象，有对应的内存空间

可以用存储期storage duration来描述对象，标识符identifier用来访问对象，用作用域scope和链接linkage描述标识符



### 12.1.1 作用域

C变量的作用域可以是块作用域，函数作用域，函数原型作用域，文件作用域

在内层块中声明的变量，作用域仅局限于声明所在的块

for循环块也可以这样写

for(int i=0;i<num;i++)

函数作用域仅用于goto语句的标签

函数原型作用域用于函数原型中的形参名，声明时原型中的形参变量名并不重要，因为它们的作用域仅限于声明语句本身

变量定义在函数外面，就具有文件作用域，也被称为全局变量

C预处理会把#include中的文件都替换到include指令

，编译器源代码文件和所有的头文件都看成是一个单独文件被称为翻译单元

### 12.1.2 链接

C的变量有三种链接属性：外部链接 内部链接或无链接

具有块作用域 函数作用域或函数原型作用域的变量都是无链接变量，意味着这些变量属于定义他们的块，函数或原型私有

具有文件作用域的变量可以是外部链接或内部链接，外部链接变量可以在多文件程序中使用

内部链接变量只能在一个翻译单元中使用

外部链接变量可以在多个翻译单元中使用



如何知道文件作用域变量是内部链接还是外部链接，可以查看外部定义中是否使用了存储类别说明符static,

`static int dodgets=3;`

是内部链接

dodgets属于该文件私有

### 12.1.3 存储期

C对象有四种存储期

静态存储期 在程序执行期间一直存在，文件作用域变量具有静态存储期

线程存储期用于并发程序设计，从声明时到县城结束时一直存在，用_Thread_local 声明对象时，每个线程都获得该变量的私有备份

块存储期的变量有自动存储期，程序进入定义变量的这些变量的块时，为这些变量分配内存，退出这个块时，释放为这个变量分配的内存

块作用域变量也有可以静态存储期，声明在块中的变量时前面添加 static

![截屏2023-04-05 12.18.30](/Users/heyushu/Library/Application Support/typora-user-images/截屏2023-04-05 12.18.30.png)

### 12.1.4 自动变量

声明在块或函数头内的任何变量都属于自动存储类别，为了更明显的表示意图，可以使用关键字**auto**

int main(void)

{

​		auto int n=0;

}

auto是存储类别说明符，在C++中auto则完全不同

内层块声明的同名变量，会隐藏外层块的定义；

### 12.1.5 寄存器变量

寄存器传输访问速度更快，但存储量更小

`register int quick;`

^声明寄存器变量

不可以取地址

有可能编译器不会把声明register的变量存储到寄存器中

在函数头中使用register,便可请求形参是寄存器变量:

`void macho(register int n)`

### 12.1.6块作用域的静态变量

在块中使用static声明变量

```c
{
   static int i;
}
```

假设在块中的static i变量反复循环声明，该值不会再被赋值和分配内存；

### 12.1.7外部链接的静态变量

可以用extern关键字声明，

```c
#include<stdio.h>
extern int a;
'''
{
  extern int a;//可以直接用不用写extern;,最好写
}
```

外部变量，在函数中或块中，要么直接使用，可读性好一点的话就使用extern 声明

不能用extern创建外部定义，只能用它来引用现有的外部定义

### 12.1.8 内部链接的静态变量

static int svil;本文件可见

### 12.1.10 存储类别说明符

>  卡在了多个文件编译，等待解决

^已经解决

`gcc ./parta.c ./partb.c -o ./part`

### 12.1.11 存储类别和函数

函数也有存储类别，外部函数，静态函数，(内联函数)

```c
double gamma(double);//默认为外部函数
static double beta(int ,int);//静态函数 只在文件内有效
extern double delta(double,int);//外部函数
```

不要随意使用外部变量，

可以使用const数据进行外部变量声明保护

> 保护性程序设计的黄金法则是：“按需知道”原则，尽量在函数内部解决该函数的问题，只共享需要共享的变量

## 12.2随机数函数和静态变量

#### rand()

伪随机数生成器，可预测

## 12.4 动态分配内存 malloc()和free()

#### malloc()

接受一个所需的内存字节数

并分配该字节数的动态内存

返回动态分配内存块的首字节地址，即指向void的指针，通用指针

如果分配内存失败 则返回NULL空指针

```c
double * pd;
pd=(double *)malloc(30*sizeof(double));
```

以上代码pd指向了动态分配了30xdouble类型大小的字节内存的首地址

**要进行强制类型转换**

相当于创建了大小为30的数组

且为动态数组

可以在程序运行时选择数组大小和分配内存

与free()共同使用

#### free()

接受一个由malloc()生成的内存空间的首地址

如果内存分配失败 可以使用exit()结束程序

#### 记得要使用free()释放掉内存

#### calloc()

```c
long * newmen;
newmem=(long*)calloc(100,sizeof(long));
```

类似malloc，不同的是calloc()接受两个无符号整数作为参数，第一个表示单元数量， 第二个表示参数单元大小。

另外一个特点是，他会把块中所有位设置为0

### 12.4.3 动态内存分配和变长数组



### 12.4.4 存储类别和动态内存分配

理想化内存模型:

一部分共具有外部链接，内部链接和无链接的静态变量使用

一部分供自动变量使用

一部分供动态内存分配

静态存储类别的内存在编译时确定，程序运行前一直存在

自动存储类别的变量在变量顶以时存在，离开块时销毁

动态内存可能会比使用栈内存慢，但节省内存，按需分配









